// 문제 4-1
// 읽어 들인 정숫값의 부호를 판정하는 프로그램을 작성하자. 입력 출력을 원하는 만큼 반복할 수 있도록 한다.

#include <stdio.h>

int main(void) {
	int retry;

	do {
		int no;

		printf("정수를 입력하세요 : ");
		scanf("%d", &no);

		if (no == 0)
			puts("이 수는 0입니다.");
		else if (no > 0)
			puts("이 수는 양수입니다.");
		else
			puts("이 수는 음수입니다.");

		printf("한 번 더? [Yes...0/No...9] : ");
		scanf("%d", &retry);

	} while (retry == 0);

	return 0;
}

/* do문(do statement): do -> 구문 -> while -> ( -> 식 -> ) -> ;
   do는 '실행하라'는 의미고 while은 '~하는 동안'이라는 의미다. */
// 루프(loop): '반복'하는 구문
/* 루프 본체(loop body): do문이 반복할 대상으로 삼는 구문
   이 프로그램의 do문 loop 본체는 {부터}까지의 복합문(블록)이다.
   복합문 안에서만 이용하는 변수(여기서는 no)는 그 복합문 안에서 선언하는 것이 원칙이다. */
/* 논리 부정 연산자(logical negation operator)라고 하는 !연산자는 피연산자가 0이 같은지 판정하는
   단항 연산자다. 즉, !retry는 retry == 0과 같다.
   논리 부정 연산자   !a   a가 0이면 1, 그렇지 않으면 0(그 값은 int형) */
/* 읽을 값 제한
   이 프로그램에서 retry로 읽어 들인 값이 0이 아니면(9가 아니라도) do문의 반복을 종료한다.
   그러나 do문을 잘 활용하면 반복을 계속할지 물을 때 0 또는 9만 입력하도록 할 수 있다.
   do {
	   printf("한 번 더? [Yes...0/No...9] : ");
	   scanf("%d", &retry);
   } while (retry != 0 && retry != 9);
   이렇게 하면 do문 안에 do문이 들어가는 구조가 된다. 이러한 구조를 다중 루프라고 한다. */
/* 드모르간의 법칙(De Morgan's theorem): 각 조건의 부정을 취한 다음 논리곱, 논리합을 서로 바꾼 식의
                                    부정이 원래 조건과 같아지는 것
   x && y와 !(!x || !y)는 같다.
   x || y와 !(!x && !y)는 같다.

   이 법칙을 사용하면 앞의 코드를 다음과 같이 바꿀 수 있다.
   do {
	   printf("한 번 더? [Yes...0/No...9] : ");
	   scanf("%d", &retry);
   } while (!(retry == 0 || retry == 9));

   처음에 나온 retry != 0 && retry != 9는 반복을 계속하기 위한 계속 조건이다.
   그리고 논리 부정 연산자 !를 사용해 바꿔 쓴 식 !(retry == 0 || retry == 9)는
   반복을 종료하기 위한 종료 조건의 부정이다.*/
